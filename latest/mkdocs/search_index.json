{
    "docs": [
        {
            "location": "/", 
            "text": "Registrator\n\n\nService registry bridge for Docker, sponsored by \nWeave\n.\n\n\n\n\n\n\n\n\n\n\n\n\nRegistrator automatically registers and deregisters services for any Docker\ncontainer by inspecting containers as they come online. Registrator\nsupports pluggable service registries, which currently includes\n\nConsul\n, \netcd\n and\n\nSkyDNS 2\n.\n\n\nGetting Registrator\n\n\nGet the latest release, master, or any version of Registrator via \nDocker Hub\n:\n\n\n$ docker pull gliderlabs/registrator:latest\n\n\n\nLatest tag always points to the latest release. There is also a \n:master\n tag\nand version tags to pin to specific releases.\n\n\nUsing Registrator\n\n\nThe quickest way to see Registrator in action is our\n\nQuickstart\n tutorial. Otherwise, jump to the \nRun\nReference\n in the User Guide. Typically, running Registrator\nlooks like this:\n\n\n$ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500\n\n\n\nContributing\n\n\nPull requests are welcome! We recommend getting feedback before starting by\nopening a \nGitHub issue\n or\ndiscussing in \nSlack\n.\n\n\nAlso check out our Developer Guide on \nContributing Backends\n\nand \nStaging Releases\n.\n\n\nSponsors and Thanks\n\n\nOngoing support of this project is made possible by \nWeave\n, the easiest way to connect, observe and control your containers. Big thanks to Michael Crosby for\n\nskydock\n and the Consul mailing list\nfor inspiration.\n\n\nFor a full list of sponsors, see\n\nSPONSORS\n.\n\n\nLicense\n\n\nMIT", 
            "title": "Readme"
        }, 
        {
            "location": "/#registrator", 
            "text": "Service registry bridge for Docker, sponsored by  Weave .       Registrator automatically registers and deregisters services for any Docker\ncontainer by inspecting containers as they come online. Registrator\nsupports pluggable service registries, which currently includes Consul ,  etcd  and SkyDNS 2 .", 
            "title": "Registrator"
        }, 
        {
            "location": "/#getting-registrator", 
            "text": "Get the latest release, master, or any version of Registrator via  Docker Hub :  $ docker pull gliderlabs/registrator:latest  Latest tag always points to the latest release. There is also a  :master  tag\nand version tags to pin to specific releases.", 
            "title": "Getting Registrator"
        }, 
        {
            "location": "/#using-registrator", 
            "text": "The quickest way to see Registrator in action is our Quickstart  tutorial. Otherwise, jump to the  Run\nReference  in the User Guide. Typically, running Registrator\nlooks like this:  $ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500", 
            "title": "Using Registrator"
        }, 
        {
            "location": "/#contributing", 
            "text": "Pull requests are welcome! We recommend getting feedback before starting by\nopening a  GitHub issue  or\ndiscussing in  Slack .  Also check out our Developer Guide on  Contributing Backends \nand  Staging Releases .", 
            "title": "Contributing"
        }, 
        {
            "location": "/#sponsors-and-thanks", 
            "text": "Ongoing support of this project is made possible by  Weave , the easiest way to connect, observe and control your containers. Big thanks to Michael Crosby for skydock  and the Consul mailing list\nfor inspiration.  For a full list of sponsors, see SPONSORS .", 
            "title": "Sponsors and Thanks"
        }, 
        {
            "location": "/#license", 
            "text": "MIT", 
            "title": "License"
        }, 
        {
            "location": "/user/quickstart/", 
            "text": "Quickstart\n\n\nThis is a short, simple tutorial intended to get you started with Registrator as\nquickly as possible. For full reference, see \nRun Reference\n.\n\n\nOverview\n\n\nRegistrator watches for new Docker containers and inspects them to determine\nwhat services they provide. For our purposes, a service is anything listening on\na port. Any services Registrator finds on a container, they will be added to a\nservice registry, such as Consul or etcd.\n\n\nIn this tutorial, we're going to use Registrator with Consul, and run a Redis\ncontainer that will automatically get added to Consul.\n\n\nBefore Starting\n\n\nWe're going to need a host running Docker, which could just be a local\n\nboot2docker\n VM, and a shell with the \ndocker\n client\npointed to that host.\n\n\nWe'll also need to have Consul running, which can just be running in a\ncontainer. Let's run a single instance of Consul in server bootstrap mode:\n\n\n$ docker run -d --name=consul --net=host gliderlabs/consul-server -bootstrap\n\n\n\n\nConsul is run differently in production, but this will get us through this tutorial.\nWe can now access Consul's HTTP API via the Docker machine's IP:\n\n\n$ curl $(boot2docker ip):8500/v1/catalog/services\n{\nconsul\n:[]}\n\n\n\n\nNow we can start Registrator.\n\n\nRunning Registrator\n\n\nRegistrator is run on every host, but since we only have one host here, we can\njust run it once. The primary bit of configuration needed to start Registrator\nis how to connect to its registry, or Consul in this case.\n\n\nBesides option flags, the only argument Registrator takes is a registry URI,\nwhich encodes what type of registry, how to connect to it, and any options.\n\n\n$ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500\n\n\n\n\nThere's a bit going on here in the Docker run arguments. First, we run the\ncontainer detached and name it. We also run in host network mode. This makes\nsure Registrator has the hostname and IP of the actual host. It also makes it\neasier to connect to Consul. We also must mount the Docker socket.\n\n\nThe last line is the argument to Registrator itself, which is just our\nregistry URI. We're using \nconsul\n on \nlocalhost:8500\n, since this is running on\nthe same network interface as Consul.\n\n\n$ docker logs registrator\n\n\n\n\nWe should see it started up and \"Listening for Docker events\". That's it, it's\nworking!\n\n\nRunning Redis\n\n\nNow as you start containers, if they provide any services, they'll be added\nto Consul. We'll run Redis now from the standard library image:\n\n\n$ docker run -d -P --name=redis redis\n\n\n\n\nNotice we used \n-P\n to publish all ports. This is not often used except with\nRegistrator. Not only does it publish all exposed ports the container has, but\nit assigns them to a random port on the host. Since the point of Registrator\nand Consul is to provide service discovery, the port doesn't matter. Though\nthere can still be cases where you still want to manually specify the port.\n\n\nLet's look at Consul's services endpoint again:\n\n\n$ curl $(boot2docker ip):8500/v1/catalog/services\n{\nconsul\n:[],\nredis\n:[]}\n\n\n\n\nConsul now has a service called redis. We can see more about the service\nincluding what port was published by looking at the service endpoint for redis:\n\n\n$ curl $(boot2docker ip):8500/v1/catalog/service/redis\n[{\nNode\n:\nboot2docker\n,\nAddress\n:\n10.0.2.15\n,\nServiceID\n:\nboot2docker:redis:6379\n,\nServiceName\n:\nredis\n,\nServiceTags\n:null,\nServiceAddress\n:\n,\nServicePort\n:32768}]\n\n\n\n\nIf we remove the redis container, we can see the service is removed from Consul:\n\n\n$ docker rm -f redis\nredis\n$ curl $(boot2docker ip):8500/v1/catalog/service/redis\n[]\n\n\n\n\nThat's it! I know this may not be interesting alone, but there's a lot you can\ndo once services are registered in Consul. However, that's out of the scope of\nRegistrator. All it does is puts container services into Consul.\n\n\nNext Steps\n\n\nThere are more ways to configure Registrator and ways you can run containers to\ncustomize the services that are extracted from them. For this, take a look at\nthe \nRun Reference\n and \nService Model\n.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/user/quickstart/#quickstart", 
            "text": "This is a short, simple tutorial intended to get you started with Registrator as\nquickly as possible. For full reference, see  Run Reference .", 
            "title": "Quickstart"
        }, 
        {
            "location": "/user/quickstart/#overview", 
            "text": "Registrator watches for new Docker containers and inspects them to determine\nwhat services they provide. For our purposes, a service is anything listening on\na port. Any services Registrator finds on a container, they will be added to a\nservice registry, such as Consul or etcd.  In this tutorial, we're going to use Registrator with Consul, and run a Redis\ncontainer that will automatically get added to Consul.", 
            "title": "Overview"
        }, 
        {
            "location": "/user/quickstart/#before-starting", 
            "text": "We're going to need a host running Docker, which could just be a local boot2docker  VM, and a shell with the  docker  client\npointed to that host.  We'll also need to have Consul running, which can just be running in a\ncontainer. Let's run a single instance of Consul in server bootstrap mode:  $ docker run -d --name=consul --net=host gliderlabs/consul-server -bootstrap  Consul is run differently in production, but this will get us through this tutorial.\nWe can now access Consul's HTTP API via the Docker machine's IP:  $ curl $(boot2docker ip):8500/v1/catalog/services\n{ consul :[]}  Now we can start Registrator.", 
            "title": "Before Starting"
        }, 
        {
            "location": "/user/quickstart/#running-registrator", 
            "text": "Registrator is run on every host, but since we only have one host here, we can\njust run it once. The primary bit of configuration needed to start Registrator\nis how to connect to its registry, or Consul in this case.  Besides option flags, the only argument Registrator takes is a registry URI,\nwhich encodes what type of registry, how to connect to it, and any options.  $ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500  There's a bit going on here in the Docker run arguments. First, we run the\ncontainer detached and name it. We also run in host network mode. This makes\nsure Registrator has the hostname and IP of the actual host. It also makes it\neasier to connect to Consul. We also must mount the Docker socket.  The last line is the argument to Registrator itself, which is just our\nregistry URI. We're using  consul  on  localhost:8500 , since this is running on\nthe same network interface as Consul.  $ docker logs registrator  We should see it started up and \"Listening for Docker events\". That's it, it's\nworking!", 
            "title": "Running Registrator"
        }, 
        {
            "location": "/user/quickstart/#running-redis", 
            "text": "Now as you start containers, if they provide any services, they'll be added\nto Consul. We'll run Redis now from the standard library image:  $ docker run -d -P --name=redis redis  Notice we used  -P  to publish all ports. This is not often used except with\nRegistrator. Not only does it publish all exposed ports the container has, but\nit assigns them to a random port on the host. Since the point of Registrator\nand Consul is to provide service discovery, the port doesn't matter. Though\nthere can still be cases where you still want to manually specify the port.  Let's look at Consul's services endpoint again:  $ curl $(boot2docker ip):8500/v1/catalog/services\n{ consul :[], redis :[]}  Consul now has a service called redis. We can see more about the service\nincluding what port was published by looking at the service endpoint for redis:  $ curl $(boot2docker ip):8500/v1/catalog/service/redis\n[{ Node : boot2docker , Address : 10.0.2.15 , ServiceID : boot2docker:redis:6379 , ServiceName : redis , ServiceTags :null, ServiceAddress : , ServicePort :32768}]  If we remove the redis container, we can see the service is removed from Consul:  $ docker rm -f redis\nredis\n$ curl $(boot2docker ip):8500/v1/catalog/service/redis\n[]  That's it! I know this may not be interesting alone, but there's a lot you can\ndo once services are registered in Consul. However, that's out of the scope of\nRegistrator. All it does is puts container services into Consul.", 
            "title": "Running Redis"
        }, 
        {
            "location": "/user/quickstart/#next-steps", 
            "text": "There are more ways to configure Registrator and ways you can run containers to\ncustomize the services that are extracted from them. For this, take a look at\nthe  Run Reference  and  Service Model .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/user/run/", 
            "text": "Run Reference\n\n\nRegistrator is designed to be run once on every host. You \ncould\n run a single\nRegistrator for your cluster, but you get better scaling properties and easier\nconfiguration by ensuring Registrator runs on every host. Assuming some level of\nautomation, running everywhere is ironically simpler than running once somewhere.\n\n\nRunning Registrator\n\n\ndocker run [docker options] gliderlabs/registrator[:tag] [options] \nregistry uri\n\n\n\n\nRegistrator requires and recommends some Docker options, has its own set of options\nand then requires a Registry URI. Here is a typical way to run Registrator:\n\n\n$ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500\n\n\n\nDocker Options\n\n\n\n\n\n\n\n\nOption\n\n\nRequired\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n--volume=/var/run/docker.sock:/tmp/docker.sock\n\n\nyes\n\n\nAllows Registrator to access Docker API\n\n\n\n\n\n\n--net=host\n\n\nrecommended\n\n\nHelps Registrator get host-level IP and hostname\n\n\n\n\n\n\n\n\nAn alternative to host network mode would be to set the container hostname to the host\nhostname (\n-h $HOSTNAME\n) and using the \n-ip\n Registrator option below.\n\n\nRegistrator Options\n\n\n\n\n\n\n\n\nOption\n\n\nSince\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-cleanup\n\n\nv7\n\n\nCleanup dangling services\n\n\n\n\n\n\n-deregister \nmode\n\n\nv6\n\n\nDeregister exited services \"always\" or \"on-success\". Default: always\n\n\n\n\n\n\n-internal\n\n\n\n\nUse exposed ports instead of published ports\n\n\n\n\n\n\n-ip \nip address\n\n\n\n\nForce IP address used for registering services\n\n\n\n\n\n\n-resync \nseconds\n\n\nv6\n\n\nFrequency all services are resynchronized. Default: 0, never\n\n\n\n\n\n\n-retry-attempts \nnumber\n\n\nv7\n\n\nMax retry attempts to establish a connection with the backend\n\n\n\n\n\n\n-retry-interval \nmilliseconds\n\n\nv7\n\n\nInterval (in millisecond) between retry-attempts\n\n\n\n\n\n\n-tags \ntags\n\n\nv5\n\n\nForce comma-separated tags on all registered services\n\n\n\n\n\n\n-ttl \nseconds\n\n\n\n\nTTL for services. Default: 0, no expiry (supported backends only)\n\n\n\n\n\n\n-ttl-refresh \nseconds\n\n\n\n\nFrequency service TTLs are refreshed (supported backends only)\n\n\n\n\n\n\n-useIpFromLabel \nlabel\n\n\n\n\nUses the IP address stored in the given label, which is assigned to a container, for registration with Consul\n\n\n\n\n\n\n\n\nIf the \n-internal\n option is used, Registrator will register the docker0\ninternal IP and port instead of the host mapped ones.\n\n\nBy default, when registering a service, Registrator will assign the service\naddress by attempting to resolve the current hostname. If you would like to\nforce the service address to be a specific address, you can specify the \n-ip\n\nargument.\n\n\nFor registry backends that support TTL expiry, Registrator can both set and\nrefresh service TTLs with \n-ttl\n and \n-ttl-refresh\n.\n\n\nIf you want unlimited retry-attempts use \n-retry-attempts -1\n.\n\n\nThe \n-resync\n options controls how often Registrator will query Docker for all\ncontainers and reregister all services.  This allows Registrator and the service\nregistry to get back in sync if they fall out of sync. Use this option with caution\nas it will notify all the watches you may have registered on your services, and\nmay rapidly flood your system (e.g. consul-template makes extensive use of watches).\n\n\nConsul ACL token\n\n\nIf consul is configured to require an ACL token, Registrator needs to know about it,\nor you will see warnings in the consul docker container\n\n\n[WARN] consul.catalog: Register of service 'redis' on 'hostname' denied due to ACLs\n\n\n\nThe ACL token is passed in through docker in an environment variable called \nCONSUL_HTTP_TOKEN\n.\n\n\n$ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    -e CONSUL_HTTP_TOKEN=\nyour acl token\n \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500\n\n\n\nRegistry URI\n\n\nbackend\n://\naddress\n[/\npath\n]\n\n\n\nThe registry backend to use is defined by a URI. The scheme is the supported\nregistry name. The address is a host or host and port used to connect to the\nregistry. Some registries support a path definition used, for example, as the prefix to use\nin service definitions for key-value based registries.\n\n\nFor full reference of supported backends, see \nRegistry Backends\n.", 
            "title": "Run Reference"
        }, 
        {
            "location": "/user/run/#run-reference", 
            "text": "Registrator is designed to be run once on every host. You  could  run a single\nRegistrator for your cluster, but you get better scaling properties and easier\nconfiguration by ensuring Registrator runs on every host. Assuming some level of\nautomation, running everywhere is ironically simpler than running once somewhere.", 
            "title": "Run Reference"
        }, 
        {
            "location": "/user/run/#running-registrator", 
            "text": "docker run [docker options] gliderlabs/registrator[:tag] [options]  registry uri   Registrator requires and recommends some Docker options, has its own set of options\nand then requires a Registry URI. Here is a typical way to run Registrator:  $ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500", 
            "title": "Running Registrator"
        }, 
        {
            "location": "/user/run/#docker-options", 
            "text": "Option  Required  Description      --volume=/var/run/docker.sock:/tmp/docker.sock  yes  Allows Registrator to access Docker API    --net=host  recommended  Helps Registrator get host-level IP and hostname     An alternative to host network mode would be to set the container hostname to the host\nhostname ( -h $HOSTNAME ) and using the  -ip  Registrator option below.", 
            "title": "Docker Options"
        }, 
        {
            "location": "/user/run/#registrator-options", 
            "text": "Option  Since  Description      -cleanup  v7  Cleanup dangling services    -deregister  mode  v6  Deregister exited services \"always\" or \"on-success\". Default: always    -internal   Use exposed ports instead of published ports    -ip  ip address   Force IP address used for registering services    -resync  seconds  v6  Frequency all services are resynchronized. Default: 0, never    -retry-attempts  number  v7  Max retry attempts to establish a connection with the backend    -retry-interval  milliseconds  v7  Interval (in millisecond) between retry-attempts    -tags  tags  v5  Force comma-separated tags on all registered services    -ttl  seconds   TTL for services. Default: 0, no expiry (supported backends only)    -ttl-refresh  seconds   Frequency service TTLs are refreshed (supported backends only)    -useIpFromLabel  label   Uses the IP address stored in the given label, which is assigned to a container, for registration with Consul     If the  -internal  option is used, Registrator will register the docker0\ninternal IP and port instead of the host mapped ones.  By default, when registering a service, Registrator will assign the service\naddress by attempting to resolve the current hostname. If you would like to\nforce the service address to be a specific address, you can specify the  -ip \nargument.  For registry backends that support TTL expiry, Registrator can both set and\nrefresh service TTLs with  -ttl  and  -ttl-refresh .  If you want unlimited retry-attempts use  -retry-attempts -1 .  The  -resync  options controls how often Registrator will query Docker for all\ncontainers and reregister all services.  This allows Registrator and the service\nregistry to get back in sync if they fall out of sync. Use this option with caution\nas it will notify all the watches you may have registered on your services, and\nmay rapidly flood your system (e.g. consul-template makes extensive use of watches).", 
            "title": "Registrator Options"
        }, 
        {
            "location": "/user/run/#consul-acl-token", 
            "text": "If consul is configured to require an ACL token, Registrator needs to know about it,\nor you will see warnings in the consul docker container  [WARN] consul.catalog: Register of service 'redis' on 'hostname' denied due to ACLs  The ACL token is passed in through docker in an environment variable called  CONSUL_HTTP_TOKEN .  $ docker run -d \\\n    --name=registrator \\\n    --net=host \\\n    --volume=/var/run/docker.sock:/tmp/docker.sock \\\n    -e CONSUL_HTTP_TOKEN= your acl token  \\\n    gliderlabs/registrator:latest \\\n      consul://localhost:8500", 
            "title": "Consul ACL token"
        }, 
        {
            "location": "/user/run/#registry-uri", 
            "text": "backend :// address [/ path ]  The registry backend to use is defined by a URI. The scheme is the supported\nregistry name. The address is a host or host and port used to connect to the\nregistry. Some registries support a path definition used, for example, as the prefix to use\nin service definitions for key-value based registries.  For full reference of supported backends, see  Registry Backends .", 
            "title": "Registry URI"
        }, 
        {
            "location": "/user/services/", 
            "text": "Service Object\n\n\nRegistrator is primarily concerned with services that would be added to a\nservice discovery registry. In our case, a service is anything listening on a\nport. If a container listens on multiple ports, it has multiple services.\n\n\nServices are created with information from the container, including user-defined\nmetadata on the container, into an intermediary service object. This service\nobject is then passed to a registry backend to try and place as much of this\nobject into a particular registry.\n\n\ntype Service struct {\n    ID    string               // unique service instance ID\n    Name  string               // service name\n    IP    string               // IP address service is located at\n    Port  int                  // port service is listening on\n    Tags  []string             // extra tags to classify service\n    Attrs map[string]string    // extra attribute metadata\n}\n\n\n\nContainer Overrides\n\n\nThe fields \nName\n, \nTags\n, \nAttrs\n, and \nID\n can be overridden by user-defined\ncontainer metadata. You can use environment variables or labels prefixed with\n\nSERVICE_\n or \nSERVICE_x_\n to set values, where \nx\n is the internal exposed port.\nFor example \nSERVICE_NAME=customerdb\n and \nSERVICE_80_NAME=api\n.\n\n\nYou use a port in the key name to refer to a particular service on that port.\nMetadata variables without a port in the name are used as the default for all\nservices or can be used to conveniently refer to the single exposed service.\n\n\nThe \nAttrs\n field is populated by metadata using any other field names in the\nkey name. For example, \nSERVICE_REGION=us-east\n.\n\n\nSince metadata is stored as environment variables or labels, the container\nauthor can include their own metadata defined in the Dockerfile. The operator\nwill still be able to override these author-defined defaults.\n\n\nDetecting Services\n\n\nBy default, you can expect Registrator to pick up services from containers that\nhave \nexplicitly published ports\n (eg, using \n-p\n or \n-P\n). This is true for\ncontainers running in host network mode as well, so you'll have to publish ports\neven though it doesn't do anything networking wise:\n\n\n$ docker run --net=host -p 8080:8080 -p 8443:8443 ...\n\n\n\nIf running with the \n-internal\n option, it will instead look for exposed ports.\nThese can be implicitly set from the Dockerfile or explicitly set with \ndocker run\n--expose=8080 ...\n.\n\n\nYou can also tell Registrator to ignore a container by setting a\nlabel or environment variable for \nSERVICE_IGNORE\n.\n\n\nIf you need to ignore individual service on some container, you can use\n\nSERVICE_\nport\n_IGNORE=true\n.\n\n\nService Name\n\n\nService names are what you use in service discovery lookups. By default, the\nservice name is determined by this pattern:\n\n\nbase(container-image)\n[-\nexposed-port\n if \n1 ports]\n\n\n\nUsing the base of the container image, if the image is \ngliderlabs/foobar\n, the\nservice name is \nfoobar\n. If the image is \nredis\n the service name is simply\n\nredis\n.\n\n\nAdditionally, if a container has multiple exposed ports, it will append the\ninternal exposed port to differentiate from each other. For example, an image\n\nnginx\n with two exposed ports, 80 and 443, will produce two services named\n\nnginx-80\n and \nnginx-443\n.\n\n\nYou can override this default name with label or environment variable\n\nSERVICE_NAME\n or \nSERVICE_x_NAME\n, where \nx\n is the internal exposed port. Note\nthat if a container has multiple exposed ports then setting \nSERVICE_NAME\n will\nstill result in multiple services named \nSERVICE_NAME-\nexposed port\n.\n\n\nIP and Port\n\n\nIP and port make up the address that the service name resolves to. There are a\nnumber of ways Registrator can determine IP and port depending your setup. By\ndefault, port is the public \npublished\n port and the IP is going to try and be\nyour host IP.\n\n\nSince determining the right IP is difficult to do automatically, it's recommended\nto use the \n-ip\n option to explicitly tell Registrator what IP to use.\n\n\nIf you use the \n-internal\n option, Registrator will use the \nexposed\n port \nand\nDocker-assigned internal IP of the container\n.\n\n\nTags and Attributes\n\n\nTags and attributes are extra metadata fields for services. Not all backends\nsupport them. In fact, currently Consul supports tags and more recently as of\nversion 1.0.7, it added support for attributes as well in the form of\n\nKV metadata\n but no other\nbackend supports attributes.\n\n\nAttributes can also be used by backends for registry specific features, not just\ngeneric metadata. For example, Consul uses them for \nspecifying HTTP health\nchecks\n.\n\n\nUnique ID\n\n\nThe ID is a cluster-wide unique identifier for this service instance. For the\nmost part, it's an implementation detail, as users typically use service names,\nnot their IDs. Registrator comes up with a human-friendly string that encodes\nuseful information in the ID based on this pattern:\n\n\nhostname\n:\ncontainer-name\n:\nexposed-port\n[:udp if udp]\n\n\n\nThe ID includes the hostname to help you identify which host this service is\nrunning on. This is why running Registrator in host network mode or setting\nRegistrator's hostname to the host's hostname is important. Otherwise it will be\nthe ID of the Registrator container, which is not terribly useful.\n\n\nThe name of the container for this service is also included. It uses the name\ninstead of container ID because it's more human-friendly and user configurable.\n\n\nTo identify this particular service in the container, it uses the internal\nexposed port. This represents the port the service is listening on inside the\ncontainer. We use this because it likely better represents the service than the\npublicly published port. A published port might be an arbitrary 54292, whereas\nthe exposed port might be 80, showing that it's an HTTP service.\n\n\nLastly, if the service is identified as UDP, this is included in the ID to\ndifferentiate from a TCP service that could be listening on the same port.\n\n\nAlthough this can be overridden on containers with \nSERVICE_ID\n or\n\nSERVICE_x_ID\n, it is not recommended.\n\n\nExamples\n\n\nSingle service with defaults\n\n\n$ docker run -d --name redis.0 -p 10000:6379 progrium/redis\n\n\n\nResults in \nService\n:\n\n\n{\n    \"ID\": \"hostname:redis.0:6379\",\n    \"Name\": \"redis\",\n    \"Port\": 10000,\n    \"IP\": \"192.168.1.102\",\n    \"Tags\": [],\n    \"Attrs\": {}\n}\n\n\n\nSingle service with metadata\n\n\n$ docker run -d --name redis.0 -p 10000:6379 \\\n    -e \"SERVICE_NAME=db\" \\\n    -e \"SERVICE_TAGS=master,backups\" \\\n    -e \"SERVICE_REGION=us2\" progrium/redis\n\n\n\nResults in \nService\n:\n\n\n{\n    \"ID\": \"hostname:redis.0:6379\",\n    \"Name\": \"db\",\n    \"Port\": 10000,\n    \"IP\": \"192.168.1.102\",\n    \"Tags\": [\"master\", \"backups\"],\n    \"Attrs\": {\"region\": \"us2\"}\n}\n\n\n\nKeep in mind not all of the \nService\n object may be used by the registry backend. For example, currently none of them support registering arbitrary attributes. This field is there for future use.\n\n\nThe comma can be escaped by adding a backslash, such as the following example:\n\n\n$ docker run -d --name redis.0 -p 10000:6379 \\\n    -e \"SERVICE_NAME=db\" \\\n    -e \"SERVICE_TAGS=/(;\\\\,:-_)/\" \\\n    -e \"SERVICE_REGION=us2\" progrium/redis\n\n\n\nMultiple services with defaults\n\n\n$ docker run -d --name nginx.0 -p 4443:443 -p 8000:80 progrium/nginx\n\n\n\nResults in two \nService\n objects:\n\n\n[\n    {\n        \"ID\": \"hostname:nginx.0:443\",\n        \"Name\": \"nginx-443\",\n        \"Port\": 4443,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [],\n        \"Attrs\": {},\n    },\n    {\n        \"ID\": \"hostname:nginx.0:80\",\n        \"Name\": \"nginx-80\",\n        \"Port\": 8000,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [],\n        \"Attrs\": {}\n    }\n]\n\n\n\nMultiple services with metadata\n\n\n$ docker run -d --name nginx.0 -p 4443:443 -p 8000:80 \\\n    -e \"SERVICE_443_NAME=https\" \\\n    -e \"SERVICE_443_ID=https.12345\" \\\n    -e \"SERVICE_443_SNI=enabled\" \\\n    -e \"SERVICE_80_NAME=http\" \\\n    -e \"SERVICE_TAGS=www\" progrium/nginx\n\n\n\nResults in two \nService\n objects:\n\n\n[\n    {\n        \"ID\": \"https.12345\",\n        \"Name\": \"https\",\n        \"Port\": 4443,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [\"www\"],\n        \"Attrs\": {\"sni\": \"enabled\"},\n    },\n    {\n        \"ID\": \"hostname:nginx.0:80\",\n        \"Name\": \"http\",\n        \"Port\": 8000,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [\"www\"],\n        \"Attrs\": {}\n    }\n]\n\n\n\nUsing labels to define metadata\n\n\n$ docker run -d --name redis.0 -p 10000:6379 \\\n    -l \"SERVICE_NAME=db\" \\\n    -l \"SERVICE_TAGS=master,backups\" \\\n    -l \"SERVICE_REGION=us2\" dockerfile/redis\n\n\n\nResults in \nService\n:\n\n\n{\n    \"ID\": \"hostname:redis.0:6379\",\n    \"Name\": \"db\",\n    \"Port\": 10000,\n    \"IP\": \"192.168.1.102\",\n    \"Tags\": [\"master\", \"backups\"],\n    \"Attrs\": {\"region\": \"us2\"}\n}", 
            "title": "Service Model"
        }, 
        {
            "location": "/user/services/#service-object", 
            "text": "Registrator is primarily concerned with services that would be added to a\nservice discovery registry. In our case, a service is anything listening on a\nport. If a container listens on multiple ports, it has multiple services.  Services are created with information from the container, including user-defined\nmetadata on the container, into an intermediary service object. This service\nobject is then passed to a registry backend to try and place as much of this\nobject into a particular registry.  type Service struct {\n    ID    string               // unique service instance ID\n    Name  string               // service name\n    IP    string               // IP address service is located at\n    Port  int                  // port service is listening on\n    Tags  []string             // extra tags to classify service\n    Attrs map[string]string    // extra attribute metadata\n}", 
            "title": "Service Object"
        }, 
        {
            "location": "/user/services/#container-overrides", 
            "text": "The fields  Name ,  Tags ,  Attrs , and  ID  can be overridden by user-defined\ncontainer metadata. You can use environment variables or labels prefixed with SERVICE_  or  SERVICE_x_  to set values, where  x  is the internal exposed port.\nFor example  SERVICE_NAME=customerdb  and  SERVICE_80_NAME=api .  You use a port in the key name to refer to a particular service on that port.\nMetadata variables without a port in the name are used as the default for all\nservices or can be used to conveniently refer to the single exposed service.  The  Attrs  field is populated by metadata using any other field names in the\nkey name. For example,  SERVICE_REGION=us-east .  Since metadata is stored as environment variables or labels, the container\nauthor can include their own metadata defined in the Dockerfile. The operator\nwill still be able to override these author-defined defaults.", 
            "title": "Container Overrides"
        }, 
        {
            "location": "/user/services/#detecting-services", 
            "text": "By default, you can expect Registrator to pick up services from containers that\nhave  explicitly published ports  (eg, using  -p  or  -P ). This is true for\ncontainers running in host network mode as well, so you'll have to publish ports\neven though it doesn't do anything networking wise:  $ docker run --net=host -p 8080:8080 -p 8443:8443 ...  If running with the  -internal  option, it will instead look for exposed ports.\nThese can be implicitly set from the Dockerfile or explicitly set with  docker run\n--expose=8080 ... .  You can also tell Registrator to ignore a container by setting a\nlabel or environment variable for  SERVICE_IGNORE .  If you need to ignore individual service on some container, you can use SERVICE_ port _IGNORE=true .", 
            "title": "Detecting Services"
        }, 
        {
            "location": "/user/services/#service-name", 
            "text": "Service names are what you use in service discovery lookups. By default, the\nservice name is determined by this pattern:  base(container-image) [- exposed-port  if  1 ports]  Using the base of the container image, if the image is  gliderlabs/foobar , the\nservice name is  foobar . If the image is  redis  the service name is simply redis .  Additionally, if a container has multiple exposed ports, it will append the\ninternal exposed port to differentiate from each other. For example, an image nginx  with two exposed ports, 80 and 443, will produce two services named nginx-80  and  nginx-443 .  You can override this default name with label or environment variable SERVICE_NAME  or  SERVICE_x_NAME , where  x  is the internal exposed port. Note\nthat if a container has multiple exposed ports then setting  SERVICE_NAME  will\nstill result in multiple services named  SERVICE_NAME- exposed port .", 
            "title": "Service Name"
        }, 
        {
            "location": "/user/services/#ip-and-port", 
            "text": "IP and port make up the address that the service name resolves to. There are a\nnumber of ways Registrator can determine IP and port depending your setup. By\ndefault, port is the public  published  port and the IP is going to try and be\nyour host IP.  Since determining the right IP is difficult to do automatically, it's recommended\nto use the  -ip  option to explicitly tell Registrator what IP to use.  If you use the  -internal  option, Registrator will use the  exposed  port  and\nDocker-assigned internal IP of the container .", 
            "title": "IP and Port"
        }, 
        {
            "location": "/user/services/#tags-and-attributes", 
            "text": "Tags and attributes are extra metadata fields for services. Not all backends\nsupport them. In fact, currently Consul supports tags and more recently as of\nversion 1.0.7, it added support for attributes as well in the form of KV metadata  but no other\nbackend supports attributes.  Attributes can also be used by backends for registry specific features, not just\ngeneric metadata. For example, Consul uses them for  specifying HTTP health\nchecks .", 
            "title": "Tags and Attributes"
        }, 
        {
            "location": "/user/services/#unique-id", 
            "text": "The ID is a cluster-wide unique identifier for this service instance. For the\nmost part, it's an implementation detail, as users typically use service names,\nnot their IDs. Registrator comes up with a human-friendly string that encodes\nuseful information in the ID based on this pattern:  hostname : container-name : exposed-port [:udp if udp]  The ID includes the hostname to help you identify which host this service is\nrunning on. This is why running Registrator in host network mode or setting\nRegistrator's hostname to the host's hostname is important. Otherwise it will be\nthe ID of the Registrator container, which is not terribly useful.  The name of the container for this service is also included. It uses the name\ninstead of container ID because it's more human-friendly and user configurable.  To identify this particular service in the container, it uses the internal\nexposed port. This represents the port the service is listening on inside the\ncontainer. We use this because it likely better represents the service than the\npublicly published port. A published port might be an arbitrary 54292, whereas\nthe exposed port might be 80, showing that it's an HTTP service.  Lastly, if the service is identified as UDP, this is included in the ID to\ndifferentiate from a TCP service that could be listening on the same port.  Although this can be overridden on containers with  SERVICE_ID  or SERVICE_x_ID , it is not recommended.", 
            "title": "Unique ID"
        }, 
        {
            "location": "/user/services/#examples", 
            "text": "Single service with defaults  $ docker run -d --name redis.0 -p 10000:6379 progrium/redis  Results in  Service :  {\n    \"ID\": \"hostname:redis.0:6379\",\n    \"Name\": \"redis\",\n    \"Port\": 10000,\n    \"IP\": \"192.168.1.102\",\n    \"Tags\": [],\n    \"Attrs\": {}\n}  Single service with metadata  $ docker run -d --name redis.0 -p 10000:6379 \\\n    -e \"SERVICE_NAME=db\" \\\n    -e \"SERVICE_TAGS=master,backups\" \\\n    -e \"SERVICE_REGION=us2\" progrium/redis  Results in  Service :  {\n    \"ID\": \"hostname:redis.0:6379\",\n    \"Name\": \"db\",\n    \"Port\": 10000,\n    \"IP\": \"192.168.1.102\",\n    \"Tags\": [\"master\", \"backups\"],\n    \"Attrs\": {\"region\": \"us2\"}\n}  Keep in mind not all of the  Service  object may be used by the registry backend. For example, currently none of them support registering arbitrary attributes. This field is there for future use.  The comma can be escaped by adding a backslash, such as the following example:  $ docker run -d --name redis.0 -p 10000:6379 \\\n    -e \"SERVICE_NAME=db\" \\\n    -e \"SERVICE_TAGS=/(;\\\\,:-_)/\" \\\n    -e \"SERVICE_REGION=us2\" progrium/redis  Multiple services with defaults  $ docker run -d --name nginx.0 -p 4443:443 -p 8000:80 progrium/nginx  Results in two  Service  objects:  [\n    {\n        \"ID\": \"hostname:nginx.0:443\",\n        \"Name\": \"nginx-443\",\n        \"Port\": 4443,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [],\n        \"Attrs\": {},\n    },\n    {\n        \"ID\": \"hostname:nginx.0:80\",\n        \"Name\": \"nginx-80\",\n        \"Port\": 8000,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [],\n        \"Attrs\": {}\n    }\n]  Multiple services with metadata  $ docker run -d --name nginx.0 -p 4443:443 -p 8000:80 \\\n    -e \"SERVICE_443_NAME=https\" \\\n    -e \"SERVICE_443_ID=https.12345\" \\\n    -e \"SERVICE_443_SNI=enabled\" \\\n    -e \"SERVICE_80_NAME=http\" \\\n    -e \"SERVICE_TAGS=www\" progrium/nginx  Results in two  Service  objects:  [\n    {\n        \"ID\": \"https.12345\",\n        \"Name\": \"https\",\n        \"Port\": 4443,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [\"www\"],\n        \"Attrs\": {\"sni\": \"enabled\"},\n    },\n    {\n        \"ID\": \"hostname:nginx.0:80\",\n        \"Name\": \"http\",\n        \"Port\": 8000,\n        \"IP\": \"192.168.1.102\",\n        \"Tags\": [\"www\"],\n        \"Attrs\": {}\n    }\n]  Using labels to define metadata  $ docker run -d --name redis.0 -p 10000:6379 \\\n    -l \"SERVICE_NAME=db\" \\\n    -l \"SERVICE_TAGS=master,backups\" \\\n    -l \"SERVICE_REGION=us2\" dockerfile/redis  Results in  Service :  {\n    \"ID\": \"hostname:redis.0:6379\",\n    \"Name\": \"db\",\n    \"Port\": 10000,\n    \"IP\": \"192.168.1.102\",\n    \"Tags\": [\"master\", \"backups\"],\n    \"Attrs\": {\"region\": \"us2\"}\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/user/backends/", 
            "text": "Backend Reference\n\n\nRegistrator supports a number of backing registries. In order for Registrator to\nbe useful, you need to be running one of these. Below are the Registry URIs to\nuse for supported backends and documentation specific to their features.\n\n\nSee also \nContributing Backends\n.\n\n\nConsul\n\n\nconsul://\naddress\n:\nport\n\nconsul-unix://\nfilepath\n\nconsul-tls://\naddress\n:\nport\n\n\n\n\nConsul is the recommended registry since it specifically models services for\nservice discovery with health checks.\n\n\nIf no address and port is specified, it will default to \n127.0.0.1:8500\n.\n\n\nConsul supports tags but no arbitrary service attributes.\n\n\nWhen using the \nconsul-tls\n scheme, registrator communicates with Consul through TLS. You must set the following environment variables:\n * \nCONSUL_CACERT\n : CA file location\n * \nCONSUL_TLSCERT\n : Certificate file location\n * \nCONSUL_TLSKEY\n : Key location\n\n\nFor more information on the Consul check parameters below, see the \nAPI documentation\n.\n\n\nConsul HTTP Check\n\n\nThis feature is only available when using Consul 0.5 or newer. Containers\nspecifying these extra metadata in labels or environment will be used to\nregister an HTTP health check with the service.\n\n\nSERVICE_80_CHECK_HTTP=/health/endpoint/path\nSERVICE_80_CHECK_INTERVAL=15s\nSERVICE_80_CHECK_TIMEOUT=1s     # optional, Consul default used otherwise\n\n\n\n\nIt works for services on any port, not just 80. If its the only service,\nyou can also use \nSERVICE_CHECK_HTTP\n.\n\n\nConsul HTTPS Check\n\n\nThis feature is only available when using Consul 0.5 or newer. Containers\nspecifying these extra metedata in labels or environment will be used to\nregister an HTTPS health check with the service.\n\n\nSERVICE_443_CHECK_HTTPS=/health/endpoint/path\nSERVICE_443_CHECK_INTERVAL=15s\nSERVICE_443_CHECK_TIMEOUT=1s        # optional, Consul default used otherwise\n\n\n\n\nConsul TCP Check\n\n\nThis feature is only available when using Consul 0.6 or newer. Containers\nspecifying these extra metadata in labels or environment will be used to\nregister an TCP health check with the service.\n\n\nSERVICE_443_CHECK_TCP=true\nSERVICE_443_CHECK_INTERVAL=15s\nSERVICE_443_CHECK_TIMEOUT=3s        # optional, Consul default used otherwise\n\n\n\n\nConsul Script Check\n\n\nThis feature is tricky because it lets you specify a script check to run from\nConsul. If running Consul in a container, you're limited to what you can run\nfrom that container. For example, curl must be installed for this to work:\n\n\nSERVICE_CHECK_SCRIPT=curl --silent --fail example.com\n\n\n\n\nThe default interval for any non-TTL check is 10s, but you can set it with\n\n_CHECK_INTERVAL\n. The check command will be interpolated with the \n$SERVICE_IP\n\nand \n$SERVICE_PORT\n placeholders:\n\n\nSERVICE_CHECK_SCRIPT=nc $SERVICE_IP $SERVICE_PORT | grep OK\n\n\n\n\nConsul TTL Check\n\n\nYou can also register a TTL check with Consul. Keep in mind, this means Consul\nwill expect a regular heartbeat ping to its API to keep the service marked\nhealthy.\n\n\nSERVICE_CHECK_TTL=30s\n\n\n\n\nConsul Initial Health Check Status\n\n\nBy default when a service is registered against Consul, the state is set to \"critical\". You can specify the initial health check status.\n\n\nSERVICE_CHECK_INITIAL_STATUS=passing\n\n\n\n\nConsul Critical Service Deregistration\n\n\nConsul can deregister a service if the check is in the critical state for more than a configurable amount of time.\nIf enabled this should be much longer than any expected recoverable outage.\n\n\nSERVICE_CHECK_DEREGISTER_AFTER=10m\n\n\n\n\nConsul KV\n\n\nconsulkv://\naddress\n:\nport\n/\nprefix\n\nconsulkv-unix://\nfilepath\n:/\nprefix\n\n\n\n\nThis is a separate backend to use Consul's key-value store instead of its native\nservice catalog. This behaves more like etcd since it has similar semantics, but\ncurrently doesn't support TTLs.\n\n\nIf no address and port is specified, it will default to \n127.0.0.1:8500\n.\n\n\nUsing the prefix from the Registry URI, service definitions are stored as:\n\n\nprefix\n/\nservice-name\n/\nservice-id\n = \nip\n:\nport\n\n\n\n\nEtcd\n\n\netcd://\naddress\n:\nport\n/\nprefix\n\n\n\n\nEtcd works similar to Consul KV, except supports service TTLs. It also currently\ndoesn't support service attributes/tags.\n\n\nIf no address and port is specified, it will default to \n127.0.0.1:2379\n.\n\n\nUsing the prefix from the Registry URI, service definitions are stored as:\n\n\nprefix\n/\nservice-name\n/\nservice-id\n = \nip\n:\nport\n\n\n\n\nSkyDNS 2\n\n\nskydns2://\naddress\n:\nport\n/\ndomain\n\n\n\n\nSkyDNS 2 uses etcd, so this backend writes service definitions in a format compatible with SkyDNS 2.\nThe path may not be omitted and must be a valid DNS domain for SkyDNS.\n\n\nIf no address and port is specified, it will default to \n127.0.0.1:2379\n.\n\n\nUsing a Registry URI with the domain \ncluster.local\n, service definitions are stored as:\n\n\n/skydns/local/cluster/\nservice-name\n/\nservice-id\n = {\"host\":\"\nip\n\",\"port\":\nport\n}\n\n\n\nSkyDNS requires the service ID to be a valid DNS hostname, so this backend requires containers to\noverride service ID to a valid DNS name. Example:\n\n\n$ docker run -d --name redis-1 -e SERVICE_ID=redis-1 -p 6379:6379 redis\n\n\n\nZookeeper Store\n\n\nThe Zookeeper backend lets you publish ephemeral znodes into zookeeper. This mode is enabled by specifying a zookeeper path.  The zookeeper backend supports publishing a json znode body complete with defined service attributes/tags as well as the service name and container id. Example URIs:\n\n\n$ registrator zookeeper://zookeeper.host/basepath\n$ registrator zookeeper://192.168.1.100:9999/basepath\n\n\n\nWithin the base path specified in the zookeeper URI, registrator will create the following path tree containing a JSON entry for the service:\n\n\nservice-name\n/\nservice-port\n = \nJSON\n\n\n\n\nThe JSON will contain all infromation about the published container service. As an example, the following container start:\n\n\n docker run -i -p 80 -e 'SERVICE_80_NAME=www' -t ubuntu:14.04 /bin/bash\n\n\n\nWill result in the zookeeper path and JSON znode body:\n\n\n/basepath/www/80 = {\"Name\":\"www\",\"IP\":\"192.168.1.123\",\"PublicPort\":49153,\"PrivatePort\":80,\"ContainerID\":\"9124853ff0d1\",\"Tags\":[],\"Attrs\":{}}", 
            "title": "Registry Backends"
        }, 
        {
            "location": "/user/backends/#backend-reference", 
            "text": "Registrator supports a number of backing registries. In order for Registrator to\nbe useful, you need to be running one of these. Below are the Registry URIs to\nuse for supported backends and documentation specific to their features.  See also  Contributing Backends .", 
            "title": "Backend Reference"
        }, 
        {
            "location": "/user/backends/#consul", 
            "text": "consul:// address : port \nconsul-unix:// filepath \nconsul-tls:// address : port   Consul is the recommended registry since it specifically models services for\nservice discovery with health checks.  If no address and port is specified, it will default to  127.0.0.1:8500 .  Consul supports tags but no arbitrary service attributes.  When using the  consul-tls  scheme, registrator communicates with Consul through TLS. You must set the following environment variables:\n *  CONSUL_CACERT  : CA file location\n *  CONSUL_TLSCERT  : Certificate file location\n *  CONSUL_TLSKEY  : Key location  For more information on the Consul check parameters below, see the  API documentation .  Consul HTTP Check  This feature is only available when using Consul 0.5 or newer. Containers\nspecifying these extra metadata in labels or environment will be used to\nregister an HTTP health check with the service.  SERVICE_80_CHECK_HTTP=/health/endpoint/path\nSERVICE_80_CHECK_INTERVAL=15s\nSERVICE_80_CHECK_TIMEOUT=1s     # optional, Consul default used otherwise  It works for services on any port, not just 80. If its the only service,\nyou can also use  SERVICE_CHECK_HTTP .  Consul HTTPS Check  This feature is only available when using Consul 0.5 or newer. Containers\nspecifying these extra metedata in labels or environment will be used to\nregister an HTTPS health check with the service.  SERVICE_443_CHECK_HTTPS=/health/endpoint/path\nSERVICE_443_CHECK_INTERVAL=15s\nSERVICE_443_CHECK_TIMEOUT=1s        # optional, Consul default used otherwise  Consul TCP Check  This feature is only available when using Consul 0.6 or newer. Containers\nspecifying these extra metadata in labels or environment will be used to\nregister an TCP health check with the service.  SERVICE_443_CHECK_TCP=true\nSERVICE_443_CHECK_INTERVAL=15s\nSERVICE_443_CHECK_TIMEOUT=3s        # optional, Consul default used otherwise  Consul Script Check  This feature is tricky because it lets you specify a script check to run from\nConsul. If running Consul in a container, you're limited to what you can run\nfrom that container. For example, curl must be installed for this to work:  SERVICE_CHECK_SCRIPT=curl --silent --fail example.com  The default interval for any non-TTL check is 10s, but you can set it with _CHECK_INTERVAL . The check command will be interpolated with the  $SERVICE_IP \nand  $SERVICE_PORT  placeholders:  SERVICE_CHECK_SCRIPT=nc $SERVICE_IP $SERVICE_PORT | grep OK  Consul TTL Check  You can also register a TTL check with Consul. Keep in mind, this means Consul\nwill expect a regular heartbeat ping to its API to keep the service marked\nhealthy.  SERVICE_CHECK_TTL=30s  Consul Initial Health Check Status  By default when a service is registered against Consul, the state is set to \"critical\". You can specify the initial health check status.  SERVICE_CHECK_INITIAL_STATUS=passing  Consul Critical Service Deregistration  Consul can deregister a service if the check is in the critical state for more than a configurable amount of time.\nIf enabled this should be much longer than any expected recoverable outage.  SERVICE_CHECK_DEREGISTER_AFTER=10m", 
            "title": "Consul"
        }, 
        {
            "location": "/user/backends/#consul-kv", 
            "text": "consulkv:// address : port / prefix \nconsulkv-unix:// filepath :/ prefix   This is a separate backend to use Consul's key-value store instead of its native\nservice catalog. This behaves more like etcd since it has similar semantics, but\ncurrently doesn't support TTLs.  If no address and port is specified, it will default to  127.0.0.1:8500 .  Using the prefix from the Registry URI, service definitions are stored as:  prefix / service-name / service-id  =  ip : port", 
            "title": "Consul KV"
        }, 
        {
            "location": "/user/backends/#etcd", 
            "text": "etcd:// address : port / prefix   Etcd works similar to Consul KV, except supports service TTLs. It also currently\ndoesn't support service attributes/tags.  If no address and port is specified, it will default to  127.0.0.1:2379 .  Using the prefix from the Registry URI, service definitions are stored as:  prefix / service-name / service-id  =  ip : port", 
            "title": "Etcd"
        }, 
        {
            "location": "/user/backends/#skydns-2", 
            "text": "skydns2:// address : port / domain   SkyDNS 2 uses etcd, so this backend writes service definitions in a format compatible with SkyDNS 2.\nThe path may not be omitted and must be a valid DNS domain for SkyDNS.  If no address and port is specified, it will default to  127.0.0.1:2379 .  Using a Registry URI with the domain  cluster.local , service definitions are stored as:  /skydns/local/cluster/ service-name / service-id  = {\"host\":\" ip \",\"port\": port }  SkyDNS requires the service ID to be a valid DNS hostname, so this backend requires containers to\noverride service ID to a valid DNS name. Example:  $ docker run -d --name redis-1 -e SERVICE_ID=redis-1 -p 6379:6379 redis", 
            "title": "SkyDNS 2"
        }, 
        {
            "location": "/user/backends/#zookeeper-store", 
            "text": "The Zookeeper backend lets you publish ephemeral znodes into zookeeper. This mode is enabled by specifying a zookeeper path.  The zookeeper backend supports publishing a json znode body complete with defined service attributes/tags as well as the service name and container id. Example URIs:  $ registrator zookeeper://zookeeper.host/basepath\n$ registrator zookeeper://192.168.1.100:9999/basepath  Within the base path specified in the zookeeper URI, registrator will create the following path tree containing a JSON entry for the service:  service-name / service-port  =  JSON   The JSON will contain all infromation about the published container service. As an example, the following container start:   docker run -i -p 80 -e 'SERVICE_80_NAME=www' -t ubuntu:14.04 /bin/bash  Will result in the zookeeper path and JSON znode body:  /basepath/www/80 = {\"Name\":\"www\",\"IP\":\"192.168.1.123\",\"PublicPort\":49153,\"PrivatePort\":80,\"ContainerID\":\"9124853ff0d1\",\"Tags\":[],\"Attrs\":{}}", 
            "title": "Zookeeper Store"
        }, 
        {
            "location": "/user/faq/", 
            "text": "Frequently Asked Questions\n\n\nWhy is it registering the wrong service IP?\n\n\nIf you're getting an odd IP registered for services, such as \n127.0.0.1\n, then\nRegistrator was unable to detect the right IP. Since this is hard to do correctly,\nit's best to always set the \n-ip \naddress\n option to the IP you want it to be.", 
            "title": "FAQ"
        }, 
        {
            "location": "/user/faq/#frequently-asked-questions", 
            "text": "Why is it registering the wrong service IP?  If you're getting an odd IP registered for services, such as  127.0.0.1 , then\nRegistrator was unable to detect the right IP. Since this is hard to do correctly,\nit's best to always set the  -ip  address  option to the IP you want it to be.", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/dev/backends/", 
            "text": "Contributing Backends\n\n\nAs you can see by either the Consul or etcd source files, writing a new registry backend is easy. Just follow the example set by those two. It boils down to writing an object that implements this interface:\n\n\n    type RegistryAdapter interface {\n        Ping() error\n        Register(service *Service) error\n        Deregister(service *Service) error\n        Refresh(service *Service) error\n    }\n\n\n\n\nThe \nService\n struct looks like this:\n\n\ntype Service struct {\n    ID    string\n    Name  string\n    Port  int\n    IP    string\n    Tags  []string\n    Attrs map[string]string\n    TTL   int\n    ...\n}\n\n\n\n\nThen add a factory which accepts a uri and returns the registry adapter, and register that factory with the bridge like \nbridge.Register(new(Factory), \"\nbackend_name\n\")\n.", 
            "title": "Contributing Backends"
        }, 
        {
            "location": "/dev/backends/#contributing-backends", 
            "text": "As you can see by either the Consul or etcd source files, writing a new registry backend is easy. Just follow the example set by those two. It boils down to writing an object that implements this interface:      type RegistryAdapter interface {\n        Ping() error\n        Register(service *Service) error\n        Deregister(service *Service) error\n        Refresh(service *Service) error\n    }  The  Service  struct looks like this:  type Service struct {\n    ID    string\n    Name  string\n    Port  int\n    IP    string\n    Tags  []string\n    Attrs map[string]string\n    TTL   int\n    ...\n}  Then add a factory which accepts a uri and returns the registry adapter, and register that factory with the bridge like  bridge.Register(new(Factory), \" backend_name \") .", 
            "title": "Contributing Backends"
        }, 
        {
            "location": "/dev/releases/", 
            "text": "Staging Releases\n\n\nDon't wait for maintainers to cut a release! You can stage a release at any time\nusing GitHub. Just open a PR against the release branch from master. If merged,\na new release will automatically be cut.\n\n\nPlease be sure to bump the version and update CHANGELOG.md and include your\nchangelog text in the PR body.", 
            "title": "Staging Releases"
        }, 
        {
            "location": "/dev/releases/#staging-releases", 
            "text": "Don't wait for maintainers to cut a release! You can stage a release at any time\nusing GitHub. Just open a PR against the release branch from master. If merged,\na new release will automatically be cut.  Please be sure to bump the version and update CHANGELOG.md and include your\nchangelog text in the PR body.", 
            "title": "Staging Releases"
        }
    ]
}